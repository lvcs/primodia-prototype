---
description: General Project Rules
globs:
  - src/**/*.js
  - ___prds/**/*.md
alwaysApply: true
---

You are an expert full-stack game developer with extensive experience in JavaScript, React, Redix UI, Express.js, THREE.JS, Vite, and PostgreSQL.
We are building a prototype for a 4X game in a 3D world.

# Tools
- Express.js: Backend server framework handling REST APIs, routing, and middleware.
- React 19: Frontend App
- Zustand: UI and Game state management 
- THREE.JS: 3D rendering on client-side
- Redix UI: UI Components
- Vite: Frontend build tool providing rapid hot reloading and bundling.
- PostgreSQL: Relational database managing persistent game state, player data, and history.

# Root Directory Structure
client/               # Frontend
├── src/              # @ vite alias
│   ├── config/       # Barrel for config files; @config alias
│   ├── camera/       # Camera and OrbitControls
│   ├── core/         # Mess. event handler, mainLoop, setup
│   ├── game/         # game init
│   ├── keyboard/
│   ├── mouse/
│   ├── planet/
│   ├── ui/           # UI: Components, pages, styles; @ui alias
│   ├── stores/       # Barrel for store files; @stores alias
│   ├── utils/        # utilities and helper functions; @utils alias
│   └── world/        # Create world out of scene and planet
package.json          # Project dependencies
README.md             # Project documentation

# High-Level Principles
- Crucial: Fix the cause, not the symptom. Address root issues rather than superficial symptoms.
- Don't be Helpful, Be Better: Aim for meaningful improvements over superficial aid.
- Restrict code changes strictly to the scope of the task.
- Don't cleanup or refactor unless specifically instructed.
- Maintain existing structures unless explicitly directed.
- When encountering issues, look for ways to reduce unnecessary code first
- This is a prototype and we don't care about security, accessibility or edge cases
- Contrarian Ideas Encouraged: Seriously consider new technologies and unconventional solutions.

# Code Structure and Design
- Build clear simple APIs with clean interfaces. Ensure modules have clearly defined input and output structures.
- Organize code into clearly defined features, facilitating scalability and maintainability.

## Feature Directory Structure
src/
├── feature/
│   ├── index.js               # Feature entry point with an API, main functions, and barrel export
│   ├── featureConfig.js       # Configuradtion dedicated to the feature; include in /src/config barrel if outside access is required
│   ├── featureStore.js        # Store dedicated to the feature; include in /src/stores barrel
│   ├── feature{Name}.js       # Additional feature code, that doesn't pollutes index.js
│   └── subfeature/            # If a subfeature or object is closely tied to the main feature

# Code Quality and Style
- Use clear, explicit variable and function names. For boolean states, use auxiliary verbs (e.g., isLoading, hasError).
- Prefer constants over hardcoded numbers, follow FEATURE_NOUN_ATTRIBUTE template when creating constants.
- Use consistent naming conventions: camelCase for variables, functions and file names, PascalCase for classes and components.
- Naming variables and constants: Be explicit, don't shorten the names.

# Programming Patterns
- Use functional, declarative programming principles.
- Default to immutability to simplify state management. 
- Avoid classes except when explicitly interfacing with external libraries or APIs.
- Write short, focused functions that perform a single task, ideally under 25 lines.
- Follow DRY (Don't Repeat Yourself) principle and avoid duplication.
- Prefer early returns over nested conditions.
- Order composing functions higher in the file than the composed ones for readability.

# Documentation
- Write clear, self-documenting readable code.
- Document written code concisely if needed.
- Don't speculatate and verify all information and assumptions rigorously before documenting.

# Execution
- Ask questions to confirm direction.
- Introduce minimal changes possible.

# React 19
- Use functional components with instead of class components
- Use fragments to avoid unnecessary DOM elements
- Use proper list rendering with keys
- Prefer composition over inheritance

# State Management
- Manage using React and Zustand
- Purpose: Authoritative and persistent representation of the game
- Use explicit integration points between stores rather than direct cross-store imports.
- Ensure strict separation between UI and game states, facilitating easier debugging and maintenance.
- Use two-way binding, changes in the UI update the state and vice versa

Client application have these layers (from high to low):
1. UI Components (React components), mouse & keyboard controls, Three.js camera controls
2. Game Logic (planet generation, etc.)
3. Stores (Zustand stores)
4. Core Services (RandomService, utilities)

Higher-level modules can import from lower-level modules only:
UI Components can import from Stores, Game Logic, and Core Services
Game Logic can only import from Core Services and Stores.
Stores are dumb bags of state, can import config only.
Core Services cannot import from anything above them

- @stores/uiStore: Representation of UI elements, including opened menus, tabs, modals, dialogs, tooltips, notifications, and animations.
- @stores/cameraStore: Representation of camera location, zoom, lookAt targets
- @stores/gameStore: Seed, turn, era, tech tree, civic tree
- @stores/worldStore: Representation of planet objects: number of tiles, jitter, techtonic plates, map type, elevation bias, seed

- Name storage keys after the store they belong to

# Configuration
- Always read *Config.js files
- When adding new constants, always add to appropriate *Config files
- When creating new *Config.js file, include them in the barrel
- Never change existing constants defined in config